<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Phone - WebRTC Call</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    
    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 10px;
      overflow-x: hidden;
    }
    
    h2 { 
      color: white; 
      text-align: center; 
      margin: 10px 0 20px 0;
      font-size: 24px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    
    #status { 
      padding: 12px 15px;
      margin: 0 0 15px 0;
      background: rgba(255,255,255,0.95);
      border-radius: 12px;
      font-size: 14px;
      text-align: center;
      font-weight: 500;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .video-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 15px;
      position: relative;
    }
    
    .video-wrapper {
      position: relative;
      width: 100%;
    }
    
    .controls-overlay {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }
    
    .control-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      background: rgba(0,0,0,0.7);
      color: white;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .control-btn:active {
      transform: scale(0.9);
    }
    
    .control-btn.active {
      background: #ef4444;
    }
    
    .call-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .call-controls button {
      flex: 1;
    }
    
    video { 
      width: 100%;
      max-width: 100%;
      height: auto;
      aspect-ratio: 4/3;
      border-radius: 12px;
      border: 3px solid rgba(255,255,255,0.3);
      background: #000;
      object-fit: cover;
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
    }
    
    #local { 
      transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
    }
    
    button { 
      width: 100%;
      padding: 16px 20px;
      font-size: 18px;
      font-weight: 600;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      -webkit-appearance: none;
      touch-action: manipulation;
    }
    
    #callBtn {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      color: white;
    }
    
    #callBtn:active {
      transform: scale(0.98);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    #callBtn:disabled {
      background: #ccc;
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* iOS Safari specific fixes */
    @supports (-webkit-touch-callout: none) {
      video {
        -webkit-mask-image: -webkit-radial-gradient(white, black);
      }
    }
    
    /* Landscape mode adjustments */
    @media (orientation: landscape) and (max-height: 500px) {
      .video-container {
        flex-direction: row;
      }
      video {
        width: 48%;
      }
      h2 {
        font-size: 18px;
        margin: 5px 0;
      }
    }
    
    /* Larger screens */
    @media (min-width: 768px) {
      body {
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      .video-container {
        max-width: 600px;
        width: 100%;
      }
      button {
        max-width: 400px;
      }
      h2 {
        font-size: 32px;
      }
    }
  </style>
</head>
<body>
  <h2>üì± Phone</h2>
  <div id="status">Status: Connecting...</div>
  <div class="video-container">
    <div class="video-wrapper">
      <video id="local" autoplay muted playsinline webkit-playsinline></video>
      <div class="controls-overlay">
        <button class="control-btn" id="micBtn" onclick="toggleMic()" title="Toggle Microphone">
          üé§
        </button>
        <button class="control-btn" id="camBtn" onclick="toggleCamera()" title="Toggle Camera">
          üìπ
        </button>
      </div>
    </div>
    <video id="remote" autoplay playsinline webkit-playsinline controls></video>
  </div>
  <div class="call-controls">
    <button id="callBtn" onclick="call()" disabled>üìû Call Doctor</button>
    <button id="endBtn" onclick="endCall()" style="display:none; background: linear-gradient(135deg, #f56565 0%, #ef4444 100%);">
      ‚ùå End Call
    </button>
  </div>

  <script>
    let socket = null;
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let tracksReceived = 0;
    let isAudioEnabled = true;
    let isVideoEnabled = true;
    let inCall = false;
    let callState = {
      userId: 'phone',
      targetId: 'doctor',
      active: false
    };
    
    const statusDiv = document.getElementById('status');
    const callBtn = document.getElementById('callBtn');
    const endBtn = document.getElementById('endBtn');
    const micBtn = document.getElementById('micBtn');
    const camBtn = document.getElementById('camBtn');

    // Check for existing call on load
    window.onload = () => {
      const savedCall = localStorage.getItem('webrtc_call_state');
      if (savedCall) {
        const state = JSON.parse(savedCall);
        if (state.active && state.userId === 'phone') {
          console.log('üìû Rejoining previous call...');
          setTimeout(() => {
            initPeerConnection();
            connectWebSocket();
            getUserMedia();
          }, 1000);
        } else {
          initPeerConnection();
          connectWebSocket();
          getUserMedia();
        }
      } else {
        initPeerConnection();
        connectWebSocket();
        getUserMedia();
      }
      
      // Add event listeners to remote video for debugging
      const remoteVideo = document.getElementById('remote');
      remoteVideo.addEventListener('loadedmetadata', () => {
        console.log('‚úì Remote video metadata loaded');
      });
      remoteVideo.addEventListener('loadeddata', () => {
        console.log('‚úì Remote video data loaded');
      });
      remoteVideo.addEventListener('playing', () => {
        console.log('‚úì Remote video is playing');
      });
    };

    // Toggle microphone
    function toggleMic() {
      if (localStream) {
        const audioTrack = localStream.getAudioTracks()[0];
        if (audioTrack) {
          isAudioEnabled = !isAudioEnabled;
          audioTrack.enabled = isAudioEnabled;
          micBtn.classList.toggle('active', !isAudioEnabled);
          micBtn.textContent = isAudioEnabled ? 'üé§' : 'üîá';
          console.log('üé§ Microphone:', isAudioEnabled ? 'ON' : 'OFF');
        }
      }
    }

    // Toggle camera
    function toggleCamera() {
      if (localStream) {
        const videoTrack = localStream.getVideoTracks()[0];
        if (videoTrack) {
          isVideoEnabled = !isVideoEnabled;
          videoTrack.enabled = isVideoEnabled;
          camBtn.classList.toggle('active', !isVideoEnabled);
          camBtn.textContent = isVideoEnabled ? 'üìπ' : 'üìµ';
          console.log('üìπ Camera:', isVideoEnabled ? 'ON' : 'OFF');
        }
      }
    }

    // End call
    function endCall() {
      console.log('‚ùå Ending call...');
      
      // Close peer connection
      if (pc) {
        pc.close();
        pc = null;
      }
      
      // Clear call state
      inCall = false;
      callState.active = false;
      localStorage.setItem('webrtc_call_state', JSON.stringify(callState));
      
      // Reset UI
      callBtn.style.display = 'inline-block';
      callBtn.disabled = false;
      callBtn.textContent = 'üìû Call Doctor';
      endBtn.style.display = 'none';
      statusDiv.textContent = 'Status: Call ended';
      
      // Clear remote video
      const remoteVideo = document.getElementById('remote');
      remoteVideo.srcObject = null;
      
      // Reinitialize peer connection
      tracksReceived = 0;
      remoteStream = null;
      initPeerConnection();
    }

    // Save call state
    function saveCallState() {
      callState.active = inCall;
      localStorage.setItem('webrtc_call_state', JSON.stringify(callState));
    }

    // Initialize WebSocket connection
    function connectWebSocket() {
      statusDiv.textContent = 'Status: Connecting to server...';
      
      socket = new WebSocket("wss://web-m4g9.onrender.com");
      
      socket.onopen = () => {
        console.log("‚úì WebSocket connected");
        statusDiv.textContent = 'Status: Connected to server';
        socket.send(JSON.stringify({ type: "LOGIN", userId: "phone" }));
        
        // Enable call button once everything is ready
        if (localStream) {
          callBtn.disabled = false;
          statusDiv.textContent = 'Status: Ready to call';
        }
      };
      
      socket.onerror = (error) => {
        console.error("‚úó WebSocket error:", error);
        statusDiv.textContent = 'Status: Connection error';
      };
      
      socket.onclose = () => {
        console.log("‚úó WebSocket closed");
        statusDiv.textContent = 'Status: Disconnected - Reconnecting...';
        callBtn.disabled = true;
        
        // Try to reconnect after 2 seconds
        setTimeout(connectWebSocket, 2000);
      };
      
      socket.onmessage = async (msg) => {
        try {
          const data = JSON.parse(msg.data);
          console.log("‚Üê Received:", data.type);
          
          if (data.type === "ANSWER") {
            console.log("‚Üê Received answer, setting remote description");
            await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            console.log("‚úì Remote description set - call should connect");
            statusDiv.textContent = 'Status: Call connected!';
            callBtn.textContent = 'Connected ‚úì';
          }
          
          if (data.type === "ICE") {
            console.log("  Adding ICE candidate");
            if (pc && data.candidate) {
              await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
            }
          }
        } catch (error) {
          console.error("Error processing message:", error);
        }
      };
    }

    // Initialize peer connection
    function initPeerConnection() {
      const config = {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      };
      
      console.log("Creating peer connection with config:", config);
      pc = new RTCPeerConnection(config);
      
      pc.ontrack = (e) => {
        console.log("‚úì Received track:", e.track.kind, "from stream:", e.streams[0].id);
        console.log("Track state:", e.track.readyState, "enabled:", e.track.enabled);
        
        tracksReceived++;
        remoteStream = e.streams[0];
        
        // Wait for both audio and video tracks before setting stream
        if (tracksReceived >= 2) {
          const remoteVideo = document.getElementById('remote');
          remoteVideo.srcObject = remoteStream;
          
          console.log("‚úì Remote video stream set with both tracks");
          console.log("Stream tracks:", remoteStream.getTracks().map(t => `${t.kind} (${t.readyState})`));
          console.log("Video readyState:", remoteVideo.readyState);
          console.log("üì° Current ICE state:", pc.iceConnectionState);
          console.log("üì° Current connection state:", pc.connectionState);
          
          // Try to play immediately
          const tryPlay = () => {
            console.log("Attempting to play video...");
            remoteVideo.play().then(() => {
              console.log("‚úì‚úì‚úì Remote video is now playing!");
            }).catch(err => {
              console.error("Remote video play error:", err);
            });
          };
          
          // If metadata already loaded, play immediately
          if (remoteVideo.readyState >= 1) {
            console.log("Metadata already loaded (readyState:", remoteVideo.readyState + ")");
            tryPlay();
          } else {
            // Wait for metadata to load
            console.log("Waiting for metadata to load...");
            remoteVideo.onloadedmetadata = () => {
              console.log("‚úì Video metadata loaded event fired");
              tryPlay();
            };
          }
        } else {
          console.log(`Waiting for more tracks... (${tracksReceived}/2)`);
        }
      };
      
      pc.onicecandidate = (e) => {
        if (e.candidate) {
          console.log("‚Üí ICE candidate generated:", e.candidate.type, e.candidate.protocol);
          if (socket && socket.readyState === WebSocket.OPEN) {
            console.log("  Sending to doctor...");
            socket.send(JSON.stringify({
              type: "ICE",
              to: "doctor",
              candidate: e.candidate
            }));
          } else {
            console.error("  ‚úó Cannot send - socket not ready!");
          }
        } else {
          console.log("‚úì ICE gathering complete (null candidate)");
        }
      };
      
      pc.oniceconnectionstatechange = () => {
        console.log("üì° ICE state:", pc.iceConnectionState);
        if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
          console.log("‚úì Peer connection established!");
        }
      };
      
      pc.onconnectionstatechange = () => {
        console.log("üì° Connection state:", pc.connectionState);
        statusDiv.textContent = `Status: ${pc.connectionState}`;
      };
      
      pc.onicegatheringstatechange = () => {
        console.log("üßä ICE gathering state:", pc.iceGatheringState);
      };
    }

    // Get user media
    async function getUserMedia() {
      try {
        statusDiv.textContent = 'Status: Requesting camera access...';
        localStream = await navigator.mediaDevices.getUserMedia({ 
          video: true, 
          audio: true 
        });
        
        console.log("‚úì Got local media stream");
        const localVideo = document.getElementById('local');
        localVideo.srcObject = localStream;
        
        // Add tracks to peer connection
        localStream.getTracks().forEach(track => {
          console.log("Adding track to peer connection:", track.kind, track.id);
          pc.addTrack(track, localStream);
        });
        console.log("Total tracks added:", localStream.getTracks().length);
        
        if (socket && socket.readyState === WebSocket.OPEN) {
          callBtn.disabled = false;
          statusDiv.textContent = 'Status: Ready to call';
        } else {
          statusDiv.textContent = 'Status: Waiting for server...';
        }
      } catch (error) {
        console.error("‚úó Error getting user media:", error);
        statusDiv.textContent = 'Status: Camera access denied';
        alert("Error accessing camera/microphone: " + error.message);
      }
    }

    // Make a call
    async function call() {
      if (!localStream) {
        alert("Camera/microphone not ready yet. Please wait.");
        return;
      }
      
      if (!socket || socket.readyState !== WebSocket.OPEN) {
        alert("Not connected to server. Please wait for reconnection.");
        return;
      }
      
      try {
        callBtn.disabled = true;
        callBtn.textContent = 'Calling...';
        statusDiv.textContent = 'Status: Creating call...';
        tracksReceived = 0; // Reset for new call
        remoteStream = null;
        inCall = true;
        saveCallState();
        
        console.log("‚Üí Creating offer...");
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,
          iceRestart: false
        });
        await pc.setLocalDescription(offer);
        console.log("‚úì Local description set, sending offer");
        
        socket.send(JSON.stringify({
          type: "OFFER",
          to: "doctor",
          offer: offer
        }));
        
        // Show end call button
        callBtn.style.display = 'none';
        endBtn.style.display = 'inline-block';
        statusDiv.textContent = 'Status: Waiting for doctor to accept...';
      } catch (error) {
        console.error("‚úó Error creating offer:", error);
        statusDiv.textContent = 'Status: Call failed';
        callBtn.disabled = false;
        callBtn.textContent = 'Call Doctor';
        alert("Error starting call: " + error.message);
        inCall = false;
        saveCallState();
      }
    }

    // Initialize everything
    window.onload = () => {
      initPeerConnection();
      connectWebSocket();
      getUserMedia();
      
      // Add event listeners to remote video for debugging
      const remoteVideo = document.getElementById('remote');
      remoteVideo.addEventListener('loadedmetadata', () => {
        console.log('‚úì Remote video metadata loaded');
      });
      remoteVideo.addEventListener('loadeddata', () => {
        console.log('‚úì Remote video data loaded');
      });
      remoteVideo.addEventListener('playing', () => {
        console.log('‚úì Remote video is playing');
      });
    };
  </script>
</body>
</html>
